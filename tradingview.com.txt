// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © mindyourbuisness

// Some Volume Profile elements are inspired by @LonesomeTheBlue's volume profile script and based of © Leviathan script

//@version=6
indicator('Market sessions and Volume profile - By Leviathan', overlay = true, max_boxes_count = 500, max_bars_back = 1000)
import mindyourbuisness/CustomAlertLib/2 as CAL
// Custom Alert Middleware Function
alertFormat = input.text_area('{default}', "Custom alert message format", group="Alert Settings")
//==========================
//Inputs
//==========================
sessionType = input.string('Daily', 'Session Type', options = ['Sydney','Tokyo', 'London', 'New York', 'Daily', 'Weekly', 'Monthly', 'Quarterly', 'Yearly'])

showProf = input.bool(true, 'Show Volume Profile', group = 'Display')
showSbox = input.bool(true, 'Show Session VA Box', group = 'Display')
showWholeBox = input.bool(false, 'Show Whole Session Box', group = 'Display')
showPoc = input.bool(true, 'Show POC', group = 'Display')
showVA = input.bool(true, 'Show VAH and VAL', group = 'Display')
showVAb = input.bool(false, 'Show Value Area Box', group = 'Display')
showCur = input.bool(true, 'Show Live Zone', group = 'Display')
showLabels = input.bool(true, 'Show Session Lables', group = 'Display')
showFx = input.bool(false, 'Show Forex Sessions (no profile)', group = 'Display')
resolution = input.int(75, 'Resolution', minval = 5, tooltip = 'The higher the value, the more refined of a profile, but less profiles shown on chart', group = 'Volume Profile Settings')
VAwid = input.int(68, 'Value Area Volume %', minval = 1, maxval = 100, group = 'Volume Profile Settings')
dispMode = input.string('Mode 2', 'Bar Mode', ['Mode 1', 'Mode 2', 'Mode 3'], group = 'Volume Profile Settings')
volType = input.string('Volume', 'Profile Data Type', options = ['Volume', 'Open Interest'], group = 'Volume Profile Settings')
smoothVol = input.bool(false, 'Smooth Volume Data', tooltip = 'Useful for assets that have very large spikes in volume over large bars - helps create better profiles', group = 'Volume Profile Settings')
dataTf = ''

bullCol = input.color(color.rgb(76, 175, 79, 50), 'Up Volume', group = 'Appearance')
bearCol = input.color(color.rgb(255, 82, 82, 50), 'Down Volume', group = 'Appearance')
VAbCol = input.color(color.rgb(107, 159, 255, 90), 'Value Area Box', group = 'Appearance')
pocCol = input.color(color.red, 'POC', inline = 'p', group = 'Appearance')
pocWid = input.int(1, 'Thickness', inline = 'p', group = 'Appearance')
vahCol = input.color(color.aqua, 'VAH', inline = 'h', group = 'Appearance')
vahWid = input.int(1, 'Thickness', inline = 'h', group = 'Appearance')
valCol = input.color(color.aqua, 'VAL', inline = 'l', group = 'Appearance')
valWid = input.int(1, 'Thickness', inline = 'l', group = 'Appearance')
boxBg = input.color(color.rgb(255, 153, 0, 100), 'Box', inline = 'm', group = 'Appearance')
boxWid = input.int(1, 'Thickness', inline = 'm', group = 'Appearance')

// Add inputs for extending lines colors
extPocCol = input.color(color.yellow, 'Extended POC', inline = 'ep', group = 'Extended Lines')
extPocWid = input.int(1, 'Thickness', inline = 'ep', group = 'Extended Lines')
extVahCol = input.color(color.lime, 'Extended VAH', inline = 'eh', group = 'Extended Lines')
extVahWid = input.int(1, 'Thickness', inline = 'eh', group = 'Extended Lines')
extValCol = input.color(color.lime, 'Extended VAL', inline = 'el', group = 'Extended Lines')
extValWid = input.int(1, 'Thickness', inline = 'el', group = 'Extended Lines')

// Add input for showing signals
showSignals = input.bool(true, 'Show Sweep Signals', group = 'Signals')

//==========================
//Constants / Variable Declaration
//========================== 
var int zoneStart = 0
var int sydneyStart = 0
var int tokyoStart = 0
var int londonStart = 0
var int nyStart = 0
int lookback = bar_index - zoneStart
var activeZone = false

// Defining arrays that store the information
var vpGreen = array.new_float(resolution, 0) // Sum of volume on long bars
var vpRed = array.new_float(resolution, 0) // Same thing but with red bars
var zoneBounds = array.new_float(resolution, 0) // array that stores the highest value that can be in a zone

//Values to store current intra bar data
var array<float> ltfOpen = array.new_float(0)
var array<float> ltfClose = array.new_float(0)
var array<float> ltfHigh = array.new_float(0)
var array<float> ltfLow = array.new_float(0)
var array<float> ltfVolume = array.new_float(0)


//Last Areas
var float g_lastPoc = na
var float g_lastVah = na
var float g_lastVal = na

//Getting OI Data
string userSymbol = syminfo.prefix + ":" + syminfo.ticker
string openInterestTicker = str.format("{0}_OI", userSymbol)
string timeframe = syminfo.type == "futures" and timeframe.isintraday ? "1D" : timeframe.period
deltaOi = request.security(openInterestTicker, timeframe, close-close[1], ignore_invalid_symbol = true)

//Selecting what vol type to use
vol() =>
    out = smoothVol ? ta.ema(volume, 5) : volume
    if volType == 'Open Interest'
        out := deltaOi
        out
    out

//Getting intrabar intial data
[dO, dC, dH, dL, dV] = request.security_lower_tf(syminfo.tickerid, dataTf, [open, close, high, low, vol()])

//==========================
//Functions
//==========================
resetProfile(enable) =>
    if enable
        array.fill(vpGreen, 0)
        array.fill(vpRed, 0)
        array.clear(ltfOpen)
        array.clear(ltfHigh)
        array.clear(ltfLow)
        array.clear(ltfClose)
        array.clear(ltfVolume)

profHigh = ta.highest(high, lookback + 1)[1]
profLow = ta.lowest(low, lookback + 1)[1]

tr = ta.atr(1)
atr = ta.atr(14)

get_vol(y11, y12, y21, y22, height, vol) =>
    nz(math.max(math.min(math.max(y11, y12), math.max(y21, y22)) - math.max(math.min(y11, y12), math.min(y21, y22)), 0) * vol / height)

profileAdd(o, h, l, c, v, g, w) =>
    //Array to store how much to distribute in each zone, on scale of 1 for full gap size to 0
    zoneDist = array.new_float(resolution, 0)
    distSum = 0.0
    // Going over each zone
    for i = 0 to array.size(vpGreen) - 1 by 1
        // Checking to see if cur bar is in zone
        zoneTop = array.get(zoneBounds, i)
        zoneBot = zoneTop - g

        body_top = math.max(c, o)
        body_bot = math.min(c, o)
        itsgreen = c >= o

        topwick = h - body_top
        bottomwick = body_bot - l
        body = body_top - body_bot

        bodyvol = body * v / (2 * topwick + 2 * bottomwick + body)
        topwickvol = 2 * topwick * v / (2 * topwick + 2 * bottomwick + body)
        bottomwickvol = 2 * bottomwick * v / (2 * topwick + 2 * bottomwick + body)

        if volType == 'Volume'
            array.set(vpGreen, i, array.get(vpGreen, i) + (itsgreen ? get_vol(zoneBot, zoneTop, body_bot, body_top, body, bodyvol) : 0) + get_vol(zoneBot, zoneTop, body_top, h, topwick, topwickvol) / 2 + get_vol(zoneBot, zoneTop, body_bot, l, bottomwick, bottomwickvol) / 2)
            array.set(vpRed, i, array.get(vpRed, i) + (itsgreen ? 0 : get_vol(zoneBot, zoneTop, body_bot, body_top, body, bodyvol)) + get_vol(zoneBot, zoneTop, body_top, h, topwick, topwickvol) / 2 + get_vol(zoneBot, zoneTop, body_bot, l, bottomwick, bottomwickvol) / 2)
        else if volType == 'Open Interest'
            if v > 0
                array.set(vpGreen, i, array.get(vpGreen, i) + get_vol(zoneBot, zoneTop, body_bot, body_top, body, v)) // + get_vol(zoneBot, zoneTop, body_top, h, topwick, topwickvol) / 2 + get_vol(zoneBot, zoneTop, body_bot, l, bottomwick, bottomwickvol) / 2)
            if v < 0
                array.set(vpRed, i, array.get(vpRed, i) + get_vol(zoneBot, zoneTop, body_bot, body_top, body, -v)) // + get_vol(zoneBot, zoneTop, body_top, h, topwick, topwickvol) / 2 + get_vol(zoneBot, zoneTop, body_bot, l, bottomwick, bottomwickvol) / 2)

calcSession(update) =>
    array.fill(vpGreen, 0)
    array.fill(vpRed, 0)
    if bar_index > lookback and update
        gap = (profHigh - profLow) / resolution

        // Defining profile bounds
        for i = 0 to resolution - 1 by 1
            array.set(zoneBounds, i, profHigh - gap * i)

        // Putting each bar inside zone into the volume profile array
        if array.size(ltfOpen) > 0
            for j = 0 to array.size(ltfOpen) - 1 by 1
                profileAdd(array.get(ltfOpen, j), array.get(ltfHigh, j), array.get(ltfLow, j), array.get(ltfClose, j), array.get(ltfVolume, j), gap, 1)

pocLevel() =>
    float maxVol = 0
    int levelInd = 0
    for i = 0 to array.size(vpRed) - 1 by 1
        if array.get(vpRed, i) + array.get(vpGreen, i) > maxVol
            maxVol := array.get(vpRed, i) + array.get(vpGreen, i)
            levelInd := i
            levelInd

    float outLevel = na
    if levelInd != array.size(vpRed) - 1
        outLevel := array.get(zoneBounds, levelInd) - (array.get(zoneBounds, levelInd) - array.get(zoneBounds, levelInd + 1)) / 2
        outLevel
    outLevel

valueLevels(poc) =>
    float gap = (profHigh - profLow) / resolution
    float volSum = array.sum(vpRed) + array.sum(vpGreen)
    float volCnt = 0

    float vah = profHigh
    float val = profLow

    //Finding poc index
    int pocInd = 0
    for i = 0 to array.size(zoneBounds) - 2 by 1
        if array.get(zoneBounds, i) >= poc and array.get(zoneBounds, i + 1) < poc
            pocInd := i
            pocInd

    volCnt := volCnt + array.get(vpRed, pocInd) + array.get(vpGreen, pocInd)
    for i = 1 to array.size(vpRed) by 1
        if pocInd + i >= 0 and pocInd + i < array.size(vpRed)
            volCnt := volCnt + array.get(vpRed, pocInd + i) + array.get(vpGreen, pocInd + i)
            if volCnt >= volSum * (VAwid / 100)
                break
            else
                val := array.get(zoneBounds, pocInd + i) - gap
                val
        if pocInd - i >= 0 and pocInd - i < array.size(vpRed)
            volCnt := volCnt + array.get(vpRed, pocInd - i) + array.get(vpGreen, pocInd - i)
            if volCnt >= volSum * (VAwid / 100)
                break
            else
                vah := array.get(zoneBounds, pocInd - i)
                vah

    [val, vah]

drawNewZone(update) =>
    if bar_index > lookback and update and array.sum(vpGreen) + array.sum(vpRed) > 0
        gap = (profHigh - profLow) / resolution
        float leftMax = bar_index[lookback]
        float rightMax = bar_index[int(lookback / 1.4)]
        float rightMaxVol = array.max(vpGreen) + array.max(vpRed)
        float buffer = gap / 10
        if showLabels
            label.new((bar_index - 1 + int(leftMax)) / 2, profHigh, sessionType, color = color.rgb(0, 0, 0, 100), textcolor = chart.fg_color)
        if showProf
            for i = 0 to array.size(vpRed) - 1 by 1
                greenEnd = int(leftMax + (rightMax - leftMax) * (array.get(vpGreen, i) / rightMaxVol))
                redEnd = int(greenEnd + (rightMax - leftMax) * (array.get(vpRed, i) / rightMaxVol))
                if dispMode == 'Mode 2'
                    box.new(int(leftMax), array.get(zoneBounds, i) - buffer, greenEnd, array.get(zoneBounds, i) - gap + buffer, bgcolor = bullCol, border_width = 0)
                    box.new(greenEnd, array.get(zoneBounds, i) - buffer, redEnd, array.get(zoneBounds, i) - gap + buffer, bgcolor = bearCol, border_width = 0)
                else if dispMode == 'Mode 1'
                    box.new(int(leftMax), array.get(zoneBounds, i) - buffer, greenEnd, array.get(zoneBounds, i) - gap + buffer, bgcolor = bullCol, border_width = 0)
                else
                    box.new(int(leftMax), array.get(zoneBounds, i) - buffer, greenEnd, array.get(zoneBounds, i) - gap + buffer, bgcolor = bullCol, border_width = 0)
                    box.new(int(leftMax) - redEnd + greenEnd, array.get(zoneBounds, i) - buffer, int(leftMax), array.get(zoneBounds, i) - gap + buffer, bgcolor = bearCol, border_width = 0)

        if showWholeBox
            box.new(int(leftMax), profHigh, bar_index - 1, profLow, chart.fg_color, boxWid, line.style_dashed, bgcolor = boxBg)
        poc = pocLevel()
        [val, vah] = valueLevels(poc)
        if showPoc
            line.new(int(leftMax), poc, bar_index - 1, poc, color = pocCol, width = pocWid)
        if showVA
            line.new(int(leftMax), vah, bar_index - 1, vah, color = vahCol, width = vahWid)
            line.new(int(leftMax), val, bar_index - 1, val, color = valCol, width = valWid)
        if showVAb
            box.new(int(leftMax), vah, bar_index - 1, val, border_color = color.rgb(54, 58, 69, 100), bgcolor = VAbCol)

        [poc, vah, val]


//if update    
//    resetProfile(true)

drawCurZone(update, delete) =>
    var line pocLine = na
    var line vahLine = na
    var line valLine = na
    var box outBox = na
    var label sessionLab = na

    var redBoxes = array.new_box(array.size(vpRed), na)
    var greenBoxes = array.new_box(array.size(vpRed), na)

    if bar_index > lookback and update and array.sum(vpGreen) + array.sum(vpRed) > 0
        //Clearing the previous boxes and array
        if not na(pocLine)
            line.delete(pocLine)
        if not na(vahLine)
            line.delete(vahLine)
        if not na(valLine)
            line.delete(valLine)
        if not na(outBox)
            box.delete(outBox)
        if not na(sessionLab)
            label.delete(sessionLab)

        for i = 0 to array.size(redBoxes) - 1 by 1
            if not na(array.get(redBoxes, i))
                box.delete(array.get(redBoxes, i))
                box.delete(array.get(greenBoxes, i))


        gap = (profHigh - profLow) / resolution
        float leftMax = bar_index[lookback]
        float rightMax = bar_index[int(lookback / 1.4)]
        float rightMaxVol = array.max(vpGreen) + array.max(vpRed)
        float buffer = gap / 10
        if showLabels
            sessionLab := label.new((bar_index - 1 + int(leftMax)) / 2, profHigh, sessionType, color = color.rgb(0, 0, 0, 100), textcolor = chart.fg_color)
            sessionLab
        if showProf
            for i = 0 to array.size(vpRed) - 1 by 1
                greenEnd = int(leftMax + (rightMax - leftMax) * (array.get(vpGreen, i) / rightMaxVol))
                redEnd = int(greenEnd + (rightMax - leftMax) * (array.get(vpRed, i) / rightMaxVol))
                if dispMode == 'Mode 2'
                    array.set(greenBoxes, i, box.new(int(leftMax), array.get(zoneBounds, i) - buffer, greenEnd, array.get(zoneBounds, i) - gap + buffer, bgcolor = bullCol, border_width = 0))
                    array.set(redBoxes, i, box.new(greenEnd, array.get(zoneBounds, i) - buffer, redEnd, array.get(zoneBounds, i) - gap + buffer, bgcolor = bearCol, border_width = 0))
                else if dispMode == 'Mode 1'
                    array.set(greenBoxes, i, box.new(int(leftMax), array.get(zoneBounds, i) - buffer, greenEnd, array.get(zoneBounds, i) - gap + buffer, bgcolor = bullCol, border_width = 0))
                else
                    array.set(greenBoxes, i, box.new(int(leftMax), array.get(zoneBounds, i) - buffer, greenEnd, array.get(zoneBounds, i) - gap + buffer, bgcolor = bullCol, border_width = 0))
                    array.set(redBoxes, i, box.new(int(leftMax) - redEnd + greenEnd, array.get(zoneBounds, i) - buffer, int(leftMax), array.get(zoneBounds, i) - gap + buffer, bgcolor = bearCol, border_width = 0))

        if showWholeBox
            outBox := box.new(int(leftMax), profHigh, bar_index - 1, profLow, chart.fg_color, boxWid, line.style_dashed, bgcolor = boxBg)


        poc = pocLevel()
        [val, vah] = valueLevels(poc)
        if showPoc
            line.delete(pocLine)
            pocLine := line.new(int(leftMax), poc, bar_index - 1, poc, color = pocCol, width = pocWid)
            pocLine
        if showVA
            line.delete(vahLine)
            line.delete(valLine)
            vahLine := line.new(int(leftMax), vah, bar_index - 1, vah, color = vahCol, width = vahWid)
            valLine := line.new(int(leftMax), val, bar_index - 1, val, color = valCol, width = valWid)
            valLine
        if showVAb
            box.new(int(leftMax), vah, bar_index - 1, val, border_color = color.rgb(54, 58, 69, 100), bgcolor = VAbCol)

    if delete
        box.delete(outBox)
        line.delete(pocLine)
        line.delete(vahLine)
        line.delete(valLine)
        for i = 0 to array.size(greenBoxes) - 1 by 1
            box.delete(array.get(greenBoxes, i))
        for i = 0 to array.size(redBoxes) - 1 by 1
            box.delete(array.get(redBoxes, i))

drawForexBox(startBar, title, top, bottom) =>
    box.new(int(startBar), top, bar_index - 1, bottom, chart.fg_color, boxWid, line.style_dashed, bgcolor = boxBg)
    if showLabels
        label.new((bar_index - 1 + int(startBar)) / 2, top, title, color = color.rgb(0, 0, 0, 100), textcolor = chart.fg_color)


combArray(arr1, arr2) =>
    out = array.copy(arr1)
    if array.size(arr2) > 0
        for i = 0 to array.size(arr2) - 1 by 1
            array.push(out, array.get(arr2, i))
    out

updateIntra(o, h, l, c, v) =>
    if array.size(o) > 0
        for i = 0 to array.size(o) - 1 by 1
            array.push(ltfOpen, array.get(o, i))
            array.push(ltfHigh, array.get(h, i))
            array.push(ltfLow, array.get(l, i))
            array.push(ltfClose, array.get(c, i))
            array.push(ltfVolume, array.get(v, i))


//==========================
//Calculations
//==========================
//Detecting different start dates
newDaily = dayofweek != dayofweek[1]
newWeekly = (dayofweek == dayofweek.sunday and dayofweek[1] != dayofweek.sunday) or (dayofweek[1] == dayofweek.friday and dayofweek == dayofweek.monday)
newMonthly = month != month[1]
newYearly = year != year[1]
newQuarterly = month != month[1] and (month - 1) % 3 == 0

utcHour = hour(time(timeframe.period, '0000-2400', 'GMT'), 'GMT')

// ➕ Sydney Session (Opens 22:00, Closes 7:00)
newSydney = utcHour != utcHour[1] + 1 and utcHour != utcHour[1] and utcHour == 22
endSydney = utcHour >= 7 and utcHour[1] < 7

newTokyo = utcHour != utcHour[1] + 1 and utcHour != utcHour[1]
endTokyo = utcHour >= 9 and utcHour[1] < 9

newLondon = utcHour >= 7 and utcHour[1] < 7
endLondon = utcHour >= 16 and utcHour[1] < 16

newNewYork = utcHour >= 13 and utcHour[1] < 13
endNewYork = utcHour >= 22 and utcHour[1] < 22




newSession = switch sessionType
    'Sydney'     => newSydney
    'Tokyo' => newTokyo
    'London' => newLondon
    'New York' => newNewYork
    'Daily' => newSydney
    'Weekly' => newWeekly
    'Monthly' => newMonthly
    'Yearly' => newYearly
    'Quarterly' => newQuarterly
    => newSydney

zoneEnd = switch sessionType
    'Sydney'     => endSydney
    'Tokyo' => endTokyo
    'London' => endLondon
    'New York' => endNewYork
    'Daily' => newSydney
    'Weekly' => newWeekly
    'Monthly' => newMonthly
    'Yearly' => newYearly
    'Quarterly' => newQuarterly
    => newSydney

isForex = showFx

// Add variables to store previous values and line objects
var float prev_lastPoc = na
var float prev_lastVah = na
var float prev_lastVal = na
var line pocLine = na
var line vahLine = na
var line valLine = na

//Re calculating and drawing zones
calcSession(zoneEnd or barstate.islast and showCur)
[newPoc, newVah, newVal] = drawNewZone(zoneEnd)
if zoneEnd and not na(newPoc)  // Only update globals when session ends and values are valid
    g_lastPoc := newPoc
    g_lastVah := newVah
    g_lastVal := newVal
    
    // If values changed, create new lines
    if not showCur
        if g_lastPoc != prev_lastPoc and showPoc
            line.delete(pocLine)
            pocLine := line.new(bar_index, g_lastPoc, bar_index + 1, g_lastPoc, color = extPocCol, width = extPocWid)
        if g_lastVah != prev_lastVah and showVA
            line.delete(vahLine)
            vahLine := line.new(bar_index, g_lastVah, bar_index + 1, g_lastVah, color = extVahCol, width = extVahWid)
        if g_lastVal != prev_lastVal and showVA
            line.delete(valLine)
            valLine := line.new(bar_index, g_lastVal, bar_index + 1, g_lastVal, color = extValCol, width = extValWid)
    
    // Update previous values
    prev_lastPoc := g_lastPoc
    prev_lastVah := g_lastVah
    prev_lastVal := g_lastVal

// Extend lines to current bar if they exist
if not showCur and not na(pocLine)
    line.set_x2(pocLine, bar_index)
    if not na(vahLine)
        line.set_x2(vahLine, bar_index)
    if not na(valLine)
        line.set_x2(valLine, bar_index)



// Signal calculations
float bodyRange = high - low
float closePosition = (close - low) / bodyRange
// Calculate wick sizes
float upperWick = high - math.max(open, close)
float lowerWick = math.min(open, close) - low

// VAH sweeps
vahBullishSweep1 = low < g_lastVah and close > g_lastVah and closePosition >= 0.5 and close > math.max(open[1], close[1]) and close > math.max(open[2], close[2]) and close[1] < open[1] and close[2] < open[2] and low < low[1]
vahBullishSweep2 = low < g_lastVah and close > g_lastVah and close[1] < open[1] and upperWick[1] > lowerWick[1] and closePosition[1] <= 0.5 and close[2] > open[2] and high[1] > high[2] and close[1] < close[2] and close > high[1] and closePosition >= 0.5 and low < low[1]

vahBearishSweep1 = high > g_lastVah and close < g_lastVah and closePosition <= 0.5 and close < math.min(open[1], close[1]) and close < math.min(open[2], close[2]) and close[1] > open[1] and close[2] > open[2] and high > high[1]
vahBearishSweep2 = high > g_lastVah and close < g_lastVah and close[1] > open[1] and lowerWick[1] > upperWick[1] and closePosition[1] >= 0.5 and close[2] < open[2] and low[1] < low[2] and close[1] > close[2] and close < low[1] and closePosition <= 0.5 and high > high[1]

// VAL sweeps
valBullishSweep1 = low < g_lastVal and close > g_lastVal and closePosition >= 0.5 and close > math.max(open[1], close[1]) and close > math.max(open[2], close[2]) and close[1] < open[1] and close[2] < open[2] and low < low[1]
valBullishSweep2 = low < g_lastVal and close > g_lastVal and close[1] < open[1] and upperWick[1] > lowerWick[1] and closePosition[1] <= 0.5 and close[2] > open[2] and high[1] > high[2] and close[1] < close[2] and close > high[1] and closePosition >= 0.5 and low < low[1]

valBearishSweep1 = high > g_lastVal and close < g_lastVal and closePosition <= 0.5 and close < math.min(open[1], close[1]) and close < math.min(open[2], close[2]) and close[1] > open[1] and close[2] > open[2] and high > high[1]
valBearishSweep2 = high > g_lastVal and close < g_lastVal and close[1] > open[1] and lowerWick[1] > upperWick[1] and closePosition[1] >= 0.5 and close[2] < open[2] and low[1] < low[2] and close[1] > close[2] and close < low[1] and closePosition <= 0.5 and high > high[1]

// POC sweeps
pocBullishSweep1 = low < g_lastPoc and close > g_lastPoc and closePosition >= 0.5 and close > math.max(open[1], close[1]) and close > math.max(open[2], close[2]) and close[1] < open[1] and close[2] < open[2] and low < low[1]
pocBullishSweep2 = low < g_lastPoc and close > g_lastPoc and close[1] < open[1] and upperWick[1] > lowerWick[1] and closePosition[1] <= 0.5 and close[2] > open[2] and high[1] > high[2] and close[1] < close[2] and close > high[1] and closePosition >= 0.5 and low < low[1]

pocBearishSweep1 = high > g_lastPoc and close < g_lastPoc and closePosition <= 0.5 and close < math.min(open[1], close[1]) and close < math.min(open[2], close[2]) and close[1] > open[1] and close[2] > open[2] and high > high[1]
pocBearishSweep2 = high > g_lastPoc and close < g_lastPoc and close[1] > open[1] and lowerWick[1] > upperWick[1] and closePosition[1] >= 0.5 and close[2] < open[2] and low[1] < low[2] and close[1] > close[2] and close < low[1] and closePosition <= 0.5 and high > high[1]


// Combined sweep signals
vahBullishSweep = vahBullishSweep1 or vahBullishSweep2
vahBearishSweep = vahBearishSweep1 or vahBearishSweep2
valBullishSweep = valBullishSweep1 or valBullishSweep2
valBearishSweep = valBearishSweep1 or valBearishSweep2
pocBullishSweep = pocBullishSweep1 or pocBullishSweep2
pocBearishSweep = pocBearishSweep1 or pocBearishSweep2

// Plot sweep signals if enabled

plotshape(showSignals and vahBearishSweep, "VAH Bearish Sweep", shape.triangledown, location.abovebar, color.red)
plotshape(showSignals and vahBullishSweep, "VAH Bullish Sweep", shape.triangleup, location.belowbar, color.green)

plotshape(showSignals and valBearishSweep, "VAL Bearish Sweep", shape.triangledown, location.abovebar, color.red)
plotshape(showSignals and valBullishSweep, "VAL Bullish Sweep", shape.triangleup, location.belowbar, color.green)

plotshape(showSignals and pocBearishSweep, "POC Bearish Sweep", shape.triangledown, location.abovebar, color.red)
plotshape(showSignals and pocBullishSweep, "POC Bullish Sweep", shape.triangleup, location.belowbar, color.green)

// Alerts
if vahBearishSweep
    CAL.customAlert(alertFormat, "VAH Bearish Sweep on " + syminfo.ticker + " - Price: " + str.tostring(g_lastVah)) // Alert #1: VAH Bearish Sweep
if vahBullishSweep
    CAL.customAlert(alertFormat, "VAH Bullish Sweep on " + syminfo.ticker + " - Price: " + str.tostring(g_lastVah)) // Alert #2: VAH Bullish Sweep

if valBearishSweep
    CAL.customAlert(alertFormat, "VAL Bearish Sweep on " + syminfo.ticker + " - Price: " + str.tostring(g_lastVal)) // Alert #3: VAL Bearish Sweep
if valBullishSweep
    CAL.customAlert(alertFormat, "VAL Bullish Sweep on " + syminfo.ticker + " - Price: " + str.tostring(g_lastVal)) // Alert #4: VAL Bullish Sweep

if pocBearishSweep
    CAL.customAlert(alertFormat, "POC Bearish Sweep on " + syminfo.ticker + " - Price: " + str.tostring(g_lastPoc)) // Alert #5: POC Bearish Sweep
if pocBullishSweep
    CAL.customAlert(alertFormat, "POC Bullish Sweep on " + syminfo.ticker + " - Price: " + str.tostring(g_lastPoc)) // Alert #6: POC Bullish Sweep

// ... rest of the code ...
drawCurZone(barstate.islast and not zoneEnd and showCur and activeZone, zoneEnd)

//Reseting profie at start of new zone
resetProfile(newSession)

//Updating data arrays
updateIntra(dO, dH, dL, dC, dV)

//Reseting zone start value
if zoneEnd
    activeZone := false
    activeZone

if newSession
    zoneStart := bar_index
    activeZone := true
    activeZone
if newSydney
    sydneyStart := bar_index
if newLondon
    londonStart := bar_index
    londonStart
if newTokyo
    tokyoStart := bar_index
    tokyoStart
if newNewYork
    nyStart := bar_index
    nyStart


var float sydneyHigh = na
var float londonHigh = na
var float tokyoHigh = na
var float nyHigh = na

var float londonLow = na
var float tokyoLow = na
var float nyLow = na
var float sydneyLow = na

if (timeframe.isintraday and timeframe.multiplier <= 60)
    sydneyHigh := ta.highest(high, bar_index - sydneyStart + 1)
    londonHigh := ta.highest(high, bar_index - londonStart + 1)
    tokyoHigh := ta.highest(high, bar_index - tokyoStart + 1)
    nyHigh := ta.highest(high, bar_index - nyStart + 1)
    

    londonLow := ta.lowest(low, bar_index - londonStart + 1)
    tokyoLow := ta.lowest(low, bar_index - tokyoStart + 1)
    nyLow := ta.lowest(low, bar_index - nyStart + 1)
    sydneyLow  := ta.lowest(low, bar_index - sydneyStart + 1)

if endLondon and isForex
    drawForexBox(londonStart, 'London', londonHigh, londonLow)
if endNewYork and isForex
    drawForexBox(nyStart, 'New York', nyHigh, nyLow)
if endTokyo and isForex
    drawForexBox(tokyoStart, 'Tokyo', tokyoHigh, tokyoLow)
if endSydney and isForex
    drawForexBox(sydneyStart, 'Sydney', sydneyHigh, sydneyLow)

//@version=6
//indicator("Supertrend", overlay = true, timeframe = "", timeframe_gaps = true)

atrPeriod = input.int(10, 'ATR Length', minval = 1)
factor = input.float(3, 'Factor', minval = 0.01, step = 0.01)

[supertrend, direction] = ta.supertrend(factor, atrPeriod)

supertrend := barstate.isfirst ? na : supertrend
upTrend = plot(direction < 0 ? supertrend : na, 'Up Trend', color = #0bd31f, style = plot.style_linebr)
downTrend = plot(direction < 0 ? na : supertrend, 'Down Trend', color = #d41818, style = plot.style_linebr)
bodyMiddle = plot(barstate.isfirst ? na : (open + close) / 2, 'Body Middle', display = display.none)

fill(bodyMiddle, upTrend, color.new(color.green, 90), fillgaps = false)
fill(bodyMiddle, downTrend, color.new(color.red, 90), fillgaps = false)

alertcondition(direction[1] > direction, title = 'Downtrend to Uptrend', message = 'The Supertrend value switched from Downtrend to Uptrend ')
alertcondition(direction[1] < direction, title = 'Uptrend to Downtrend', message = 'The Supertrend value switched from Uptrend to Downtrend')
alertcondition(direction[1] != direction, title = 'Trend Change', message = 'The Supertrend value switched from Uptrend to Downtrend or vice versa')
//@version=6
//indicator(shorttitle="BB", title="Bollinger Bands", overlay=true, timeframe="", timeframe_gaps=true)
length = input.int(20, minval = 1)
maType = input.string('SMA', 'Basis MA Type', options = ['SMA', 'EMA', 'SMMA (RMA)', 'WMA', 'VWMA'])
src = input(close, title = 'Source')
mult = input.float(2.0, minval = 0.001, maxval = 50, title = 'StdDev')

ma(source, length, _type) =>
    switch _type
        'SMA' => ta.sma(source, length)
        'EMA' => ta.ema(source, length)
        'SMMA (RMA)' => ta.rma(source, length)
        'WMA' => ta.wma(source, length)
        'VWMA' => ta.vwma(source, length)

basis = ma(src, length, maType)
dev = mult * ta.stdev(src, length)
upper = basis + dev
lower = basis - dev
offset = input.int(0, 'Offset', minval = -500, maxval = 500, display = display.data_window)
plot(basis, 'Basis', color = color.rgb(224, 8, 37, 21), offset = offset)
p1 = plot(upper, 'Upper', color = #e7e7e7, offset = offset)
p2 = plot(lower, 'Lower', color = #dbdddd, offset = offset)

//@version=6
//indicator(title='50 MultiEMA Bicolor Multi-Timeframe', shorttitle='MTF_EMA_Bicolor', overlay=true)

// === Inputs ===
len50 = input.int(50, minval = 1, title = 'Length')
src50 = input.source(close, title = 'Source')
tf = input.timeframe('30', title = 'Higher Timeframe') // Selectable timeframe

// === MTF Calculation ===
sma50_htf = request.security(syminfo.tickerid, tf, ta.sma(src50, len50))
price_htf = request.security(syminfo.tickerid, tf, src50)

// === Plot Color Based on Higher Timeframe EMA ===
plotColour = price_htf > sma50_htf ? color.green : color.red

// === Plot ===
plot(series = sma50_htf, linewidth = 2, title = 'HTF EMA', color = plotColour)


//@version=6
//indicator(title="Volume Weighted Average Price", shorttitle="VWAP", overlay=true, timeframe="", timeframe_gaps=true)

hideonDWM = input(false, title="Hide VWAP on 1D or Above", group="VWAP Settings", display = display.data_window)
var anchor = input.string(defval = "Session", title="Anchor Period",
 options=["Session", "Week", "Month", "Quarter", "Year", "Decade", "Century", "Earnings", "Dividends", "Splits"], group="VWAP Settings")
src_k = input(title = "Source", defval = hlc3, group="VWAP Settings", display = display.data_window)
offset_k = input.int(0, title="Offset_k", group="VWAP Settings", minval=0, display = display.data_window)

BANDS_GROUP = "Bands Settings"
CALC_MODE_TOOLTIP = "Determines the units used to calculate the distance of the bands. When 'Percentage' is selected, a multiplier of 1 means 1%."
calcModeInput = input.string("Standard Deviation", "Bands Calculation Mode", options = ["Standard Deviation", "Percentage"], group = BANDS_GROUP, tooltip = CALC_MODE_TOOLTIP, display = display.data_window)
showBand_1 = input(true, title = "", group = BANDS_GROUP, inline = "band_1", display = display.data_window)
bandMult_1 = input.float(1.0, title = "Bands Multiplier #1", group = BANDS_GROUP, inline = "band_1", step = 0.5, minval=0, display = display.data_window)
showBand_2 = input(false, title = "", group = BANDS_GROUP, inline = "band_2", display = display.data_window)
bandMult_2 = input.float(2.0, title = "Bands Multiplier #2", group = BANDS_GROUP, inline = "band_2", step = 0.5, minval=0, display = display.data_window)
showBand_3 = input(false, title = "", group = BANDS_GROUP, inline = "band_3", display = display.data_window)
bandMult_3 = input.float(3.0, title = "Bands Multiplier #3", group = BANDS_GROUP, inline = "band_3", step = 0.5, minval=0, display = display.data_window)

cumVolume = ta.cum(volume)
if barstate.islast and cumVolume == 0
    runtime.error("No volume is provided by the data vendor.")

new_earnings = request.earnings(syminfo.tickerid, earnings.actual, barmerge.gaps_on, barmerge.lookahead_on, ignore_invalid_symbol=true)
new_dividends = request.dividends(syminfo.tickerid, dividends.gross, barmerge.gaps_on, barmerge.lookahead_on, ignore_invalid_symbol=true)
new_split = request.splits(syminfo.tickerid, splits.denominator, barmerge.gaps_on, barmerge.lookahead_on, ignore_invalid_symbol=true)

isNewPeriod = switch anchor
	"Earnings"  => not na(new_earnings)
	"Dividends" => not na(new_dividends)
	"Splits"    => not na(new_split)
	"Session"   => timeframe.change("D")
	"Week"      => timeframe.change("W")
	"Month"     => timeframe.change("M")
	"Quarter"   => timeframe.change("3M")
	"Year"      => timeframe.change("12M")
	"Decade"    => timeframe.change("12M") and year % 10 == 0
	"Century"   => timeframe.change("12M") and year % 100 == 0
	=> false

isEsdAnchor = anchor == "Earnings" or anchor == "Dividends" or anchor == "Splits"
if na(src_k[1]) and not isEsdAnchor
	isNewPeriod := true

float vwapValue = na
float upperBandValue1 = na
float lowerBandValue1 = na
float upperBandValue2 = na
float lowerBandValue2 = na
float upperBandValue3 = na
float lowerBandValue3 = na

if not (hideonDWM and timeframe.isdwm)
    [_vwap, _stdevUpper, _] = ta.vwap(src_k, isNewPeriod, 1)
	vwapValue := _vwap
    stdevAbs = _stdevUpper - _vwap
	bandBasis = calcModeInput == "Standard Deviation" ? stdevAbs : _vwap * 0.01
	upperBandValue1 := _vwap + bandBasis * bandMult_1
	lowerBandValue1 := _vwap - bandBasis * bandMult_1
	upperBandValue2 := _vwap + bandBasis * bandMult_2
	lowerBandValue2 := _vwap - bandBasis * bandMult_2
	upperBandValue3 := _vwap + bandBasis * bandMult_3
	lowerBandValue3 := _vwap - bandBasis * bandMult_3

plot(vwapValue, title = "VWAP", color = #2962FF, offset = offset_k)

upperBand_1 = plot(upperBandValue1, title="Upper Band #1", color = color.green, offset= offset_k, display = showBand_1 ? display.all : display.none, editable = showBand_1)
lowerBand_1 = plot(lowerBandValue1, title="Lower Band #1", color = color.green, offset = offset_k, display = showBand_1 ? display.all : display.none, editable = showBand_1)
fill(upperBand_1, lowerBand_1,      title="Bands Fill #1", color = color.new(color.green, 95),   display = showBand_1 ? display.all : display.none, editable = showBand_1)

upperBand_2 = plot(upperBandValue2, title="Upper Band #2", color = color.olive, offset = offset_k, display = showBand_2 ? display.all : display.none, editable = showBand_2)
lowerBand_2 = plot(lowerBandValue2, title="Lower Band #2", color = color.olive, offset = offset_k, display = showBand_2 ? display.all : display.none, editable = showBand_2)
fill(upperBand_2, lowerBand_2,      title="Bands Fill #2", color = color.new(color.olive, 95),   display = showBand_2 ? display.all : display.none, editable = showBand_2)

upperBand_3 = plot(upperBandValue3, title="Upper Band #3", color = color.teal, offset = offset_k, display = showBand_3 ? display.all : display.none, editable = showBand_3)
lowerBand_3 = plot(lowerBandValue3, title="Lower Band #3", color = color.teal, offset = offset_k, display = showBand_3 ? display.all : display.none, editable = showBand_3)
fill(upperBand_3, lowerBand_3,      title="Bands Fill #3", color = color.new(color.teal, 95),   display = showBand_3 ? display.all : display.none, editable = showBand_3)